using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Text;


namespace pkNX.Structures.FlatBuffers.SourceGen;

[Generator]
public class ExpandableAttributeGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var declarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node switch
                {
                    ClassDeclarationSyntax => true,
                    StructDeclarationSyntax => true,
                    _ => false,
                },
                transform: static (ctx, _) => ctx.Node)
            .Where(static node => (node switch
            {
                MemberDeclarationSyntax c => c.AttributeLists,
                _ => throw new InvalidOperationException("Unexpected node type."),
            }).SelectMany(x => x.Attributes).Any(IsFlatBufferAttribute))
            .Collect();

        context.RegisterSourceOutput(declarations, static (spc, source) =>
        {
            var sb = new StringBuilder();
            var newAttribute = GetExpandableObjectAttribute();
            // Convert to list so we can use LINQ operators like GroupBy.
            var declarationList = source.ToList();
            // Group declarations by their namespace (or global if none).
            var groups = declarationList.GroupBy(GetNamespace);

            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.ComponentModel;");
            sb.AppendLine();

            foreach (var group in groups)
            {
                var ns = group.Key;
                if (!string.IsNullOrEmpty(ns))
                {
                    sb.AppendLine($"namespace {ns}");
                    sb.AppendLine("{");
                }

                foreach (var xNode in group)
                {
                    var typeDecl = (TypeDeclarationSyntax)xNode;
                    // Convert to string with normalized whitespace.
                    var attrText = newAttribute.NormalizeWhitespace().ToFullString();

                    // Use the original declaration's modifiers, keyword, name, type parameters, and constraints.
                    var modifiers = typeDecl.Modifiers.ToFullString().Trim();
                    var keyword = typeDecl.Keyword.Text; // "class" or "struct"
                    var identifier = typeDecl.Identifier.Text;
                    var typeParameterList = typeDecl.TypeParameterList?.ToFullString() ?? "";
                    var constraintClauses = typeDecl.ConstraintClauses.Count > 0
                        ? " " + string.Join(" ", typeDecl.ConstraintClauses.Select(c => c.ToFullString()))
                        : "";

                    // If the original declaration wasn't marked partial, force it to be partial.
                    // Note: This will trigger a compile error if the original declaration isn't declared partial.
                    // Revise the generator if you would rather skip the class entirely.
                    var partialModifier = modifiers.Contains("partial") ? "" : "partial ";

                    sb.AppendLine(attrText);
                    sb.AppendLine($"{modifiers} {partialModifier}{keyword} {identifier}{typeParameterList}{constraintClauses};");
                }

                if (!string.IsNullOrEmpty(ns))
                {
                    sb.AppendLine("}"); // close namespace
                    sb.AppendLine();
                }
            }

            spc.AddSource("ExpandableAttributes.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        });
    }

    private static AttributeListSyntax GetExpandableObjectAttribute() => SyntaxFactory.AttributeList(
        SyntaxFactory.SingletonSeparatedList(
            SyntaxFactory.Attribute(
                SyntaxFactory.ParseName("TypeConverter"),
                SyntaxFactory.AttributeArgumentList(
                    SyntaxFactory.SingletonSeparatedList(
                        SyntaxFactory.AttributeArgument(
                            SyntaxFactory.ParseExpression("typeof(ExpandableObjectConverter)")
                        )
                    )
                )
            )
        )
    );

    /// <summary>
    /// Gets the full namespace of a type declaration by walking its ancestors.
    /// Returns an empty string for the global namespace.
    /// </summary>
    private static string GetNamespace(SyntaxNode node)
    {
        // Look for both regular and file-scoped namespace declarations.
        var namespaceDeclaration = node.Ancestors().OfType<BaseNamespaceDeclarationSyntax>().FirstOrDefault();
        return namespaceDeclaration != null ? namespaceDeclaration.Name.ToString() : "";
    }

    private static bool IsFlatBufferAttribute(AttributeSyntax a)
    {
        var name = a.Name.ToString();
        if (name.Contains("FlatBufferTable"))
            return true;
        if (name.Contains("FlatBufferStruct"))
            return true;
        return false;
    }
}
